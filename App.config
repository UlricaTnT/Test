一：Asp.Net MVC请求处理原理（Asp.Net mvc 是怎样进入请求管道的。）
请求-->IIS--->ISAPIRuntime-->HttpWorkRequest-->HttpRuntime-->HttpContext-->找到Global文件，并且编译该文件-->确保Global文件中Application_Start被调用-->创建HttpApplication(池 栈)如果池中没有根据Global文件编译的类型通过反射的形式创建出HttpApplication-->获取所有的在配置文件中的HttpModues,这时System.Web.Routing下的UrlRoutingModule也获取了，执行每个Modules下的Init方法，那么UrlRoutingModule中的Init方法完成了请求管道第7个事件的注册。--->进入管道-->第7个事件触发了，执行相应的方法.--->完成了MVCHanlder的创建。---》请求管道的11与12事件之间执行MvcHandler中的ProcessRequest方法。那么该方法中去找控制器，找方法，执行方法中的代码，然后找视图最后渲染视图。



二：框架搭建
	
	1:先创建Model.
	2:创建数据访问接口层。IUserInfoDal
	在该接口中定义了常见的方法CURD以及分页方法。
	public interface IUserInfoDal
    {
      IQueryable<UserInfo> LoadEntities(System.Linq.Expressions.Expression<Func<UserInfo, bool>> whereLambda);

       IQueryable<UserInfo> LoadPageEntities<s>(int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression<Func<UserInfo, bool>> whereLambda, System.Linq.Expressions.Expression<Func<UserInfo, s>> orderbyLambda, bool isAsc);
       bool DeleteEntity(UserInfo entity);
       bool EditEntity(UserInfo entity);
       UserInfo AddEntity(UserInfo entity);
      
    }
	3:每个接口中都需要CURD以及分页方法的定义，而且这些方法的定义基本上是一致的，所以封装。封装到IBaseDal
	public interface IBaseDal<T> where T : class, new()
    {
        IQueryable<T> LoadEntities(System.Linq.Expressions.Expression<Func<T, bool>> whereLambda);

        //注意：方法泛型s
        IQueryable<T> LoadPageEntities<s>(
            int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression<Func<T, bool>> whereLambda, System.Linq.Expressions.Expression<Func<T, s>> orderByLambda, bool isAsc);

        bool DeleteEntity(T entity);
        bool EditEntity(T entity);
        T AddEntity(T entity);
    }
	
	4:让IUserInfoDal继承IBaseDal
	 public interface IUlricaDal:IBaseDal<Ulrica>
    {
        //定义自己特有的方法
    }
	5:让具体的数据操作类UserInfoDal去实现IUserInfoDal接口中的方法。
	 public class UserInfoDal :IUserInfoDal
    {
       OAEntities Db = new OAEntities();
        /// <summary>
        /// 查询过滤
        /// </summary>
        /// <param name="whereLambda"></param>
        /// <returns></returns>
        public IQueryable<UserInfo> LoadEntities(System.Linq.Expressions.Expression<Func<UserInfo, bool>> whereLambda)
        {
            return Db.UserInfo.Where<UserInfo>(whereLambda);//
        }
        /// <summary>
        /// 分页
        /// </summary>
        /// <typeparam name="s"></typeparam>
        /// <param name="pageIndex"></param>
        /// <param name="pageSize"></param>
        /// <param name="totalCount"></param>
        /// <param name="whereLambda"></param>
        /// <param name="orderbyLambda"></param>
        /// <param name="isAsc"></param>
        /// <returns></returns>
        public IQueryable<UserInfo> LoadPageEntities<s>(int pageIndex, int pageSize, out int totalCount, System.Linq.Expressions.Expression<Func<UserInfo, bool>> whereLambda, System.Linq.Expressions.Expression<Func<UserInfo, s>> orderbyLambda, bool isAsc)
        {
            var temp = Db.UserInfo.Where<UserInfo>(whereLambda);
            totalCount = temp.Count();
            if (isAsc)//升序
            {
                temp = temp.OrderBy<UserInfo, s>(orderbyLambda).Skip<UserInfo>((pageIndex - 1) * pageSize).Take<UserInfo>(pageSize);
            }
            else
            {
                temp = temp.OrderByDescending<UserInfo, s>(orderbyLambda).Skip<UserInfo>((pageIndex - 1) * pageSize).Take<UserInfo>(pageSize);
            }
            return temp;

        }

        /// <summary>
        /// 删除
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public bool DeleteEntity(UserInfo entity)
        {
            Db.Entry<UserInfo>(entity).State = System.Data.EntityState.Deleted;
            return Db.SaveChanges() > 0;
        }
        /// <summary>
        /// 更新
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public bool EditEntity(UserInfo entity)
        {
            Db.Entry<UserInfo>(entity).State = System.Data.EntityState.Modified;
            return Db.SaveChanges() > 0;
        }
        /// <summary>
        /// 添加数据
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public UserInfo AddEntity(UserInfo entity)
        {

            Db.Set <UserInfo>().Add(entity);
            Db.SaveChanges();
            return entity;

        }
    }
	
	6:由于每个数据操作类都要实现自己的接口（每一个接口都继承了IBaseDal）,所以每个数据操作类中都要重复实现CURD以及分页的方法，所以把具体的实现封装到了BaseDal中。
	public class BaseDal<T> where T : class, new()
    {
        CSharpTrainingEntities Db = new CSharpTrainingEntities();

        /// <summary>
        /// 添加
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public T AddEntity(T entity)
        {
            Db.Set<T>().Add(entity);
            Db.SaveChanges();
            return entity;
        }

        /// <summary>
        /// 删除
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public bool DeleteEntity(T entity)
        {
            Db.Entry<T>(entity).State = System.Data.Entity.EntityState.Deleted;
            return Db.SaveChanges() > 0;
        }

        /// <summary>
        /// 修改
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public bool EditEntity(T entity)
        {
            Db.Entry<T>(entity).State = System.Data.Entity.EntityState.Modified;
            return Db.SaveChanges() > 0;
        }

        /// <summary>
        /// 查询
        /// </summary>
        /// <param name="whereLambda"></param>
        /// <returns></returns>
        public IQueryable<T> LoadEntities(Expression<Func<T, bool>> whereLambda)
        {
            return Db.Set<T>().Where<T>(whereLambda);//DbSet<T>
        }


        /// <summary>
        /// 分页查询
        /// </summary>
        /// <typeparam name="s"></typeparam>
        /// <param name="pageIndex"></param>
        /// <param name="pageSize"></param>
        /// <param name="totalCount"></param>
        /// <param name="whereLambda"></param>
        /// <param name="orderByLambda"></param>
        /// <param name="isAsc"></param>
        /// <returns></returns>
        public IQueryable<T> LoadPageEntities<s>(int pageIndex, int pageSize, out int totalCount, Expression<Func<T, bool>> whereLambda, Expression<Func<T, s>> orderByLambda, bool isAsc)
        {
            var temp = Db.Set<T>().Where<T>(whereLambda);
            totalCount = temp.Count();
            if (isAsc)//升序
            {
                temp = temp.OrderBy<T, s>(orderByLambda).Skip<T>((pageIndex - 1) * pageSize).Take<T>(pageSize);
            }
            else
            {
                temp = temp.OrderByDescending<T, s>(orderByLambda).Skip<T>((pageIndex - 1) * pageSize).Take<T>(pageSize);
            }
            return temp;
        }
    } 
		
  7:让UserInfoDal继承BaseDal.
 public class UlricaDal : BaseDal<Ulrica>, IUlricaDal
    {

    } 
	
8:创建DBSession(数据会话层：就是一个工厂类，负责完成所有数据操作类实例的创建，然后业务层通过数据会话层来获取要操作数据类的实例。所以数据会话层将业务层与数据层解耦。
    /// 在数据会话层中提供一个方法：完成所有数据的保存。)
	在DalFactory中建，引用：model dal idal+两个dll文件	
	
	 public class DBSession
    {
        CSharpTrainingEntities Db = new CSharpTrainingEntities();

        private IUlricaDal _ulricaDal;
        public IUlricaDal UlricaDal
        {
            get
            {
                if (_ulricaDal==null)
                {
                    //_ulricaDal = new UlricaDal();//线程内唯一
                }
                return _ulricaDal;
            }
            set
            {
                _ulricaDal = value;
            }
        }
	   
9: /// <summary>
        /// 一个业务中经常涉及对多张表的操作，我们希望连接一次数据库，完成对多张表数据的操作。工作单元模式
        /// </summary>
        /// <returns></returns>
        public bool SaveChenges()
        {
            return Db.SaveChanges() > 0;
        }


10:将数据层中的所有的保存数据的SaveChanges注释掉。

11：在数据层中用到了EF的实例，数据会话层中也用到了，所以在一个请求中只能创建一个EF实例（线程内唯一对象）	   
		
		在Dal层中
    public class DBContextFactory
    {
        public static DbContext CreateDbContext()
        {
            //使用CallContext来保证线程内唯一
            DbContext dbContext = (DbContext)CallContext.GetData("dbContext");
            if (dbContext==null)
            {
                dbContext = new CSharpTrainingEntities();
                CallContext.SetData("dbContext", dbContext);
            }
            return dbContext;
        }
    }
	
12：在DBSession和BaseDal中调用上面的方法（CreateDbContext）完成EF实例的创建。
		DBSession获取EF实例
		
 //CSharpTrainingEntities Db = new CSharpTrainingEntities();

        public DbContext Db
        {
            get
            {
                return DBContextFactory.CreateDbContext();
            }
        }
	   
	   BaseDal中获取EF的实例
	   
	    //CSharpTrainingEntities Db = new CSharpTrainingEntities();

        DbContext Db = DAL.DBContextFactory.CreateDbContext();

	
	
13：抽象抽象工厂封装数据操作类实例创建，然后DBSession调用抽象工厂。
	
	修改配置文件：web.config	
	 <appSettings>
	 
    <add key="webpages:Version" value="3.0.0.0" />
    <add key="webpages:Enabled" value="false" />
    <add key="ClientValidationEnabled" value="true" />
    <add key="UnobtrusiveJavaScriptEnabled" value="true" />

    <!--配置程序集名称与明明空间的名称-->
    <add key="AssemblyPath" value="CSharpTraining.DAL"/>
    <add key="NameSpace" value="CSharpTraining.DAL"/>
        
  </appSettings>
	
	
	 namespace CSharpTraining.DALFactory
{
    /// <summary>
    /// 通过反射创建类的实例
    /// </summary>
    public class AbstractFactory
    {
        //通过web.config配置文件获得
        private static readonly string AssemblyPath = ConfigurationManager.AppSettings["AssemblyPath"];
        private static readonly string NameSpace = ConfigurationManager.AppSettings["NameSpace"];

        public static IUlricaDal CreateUlricaDal()
        {
            string fullClassName = NameSpace + ".UlricaDal";
            return CreateInstance(fullClassName) as IUlricaDal;
        }
        private static object CreateInstance(string className)
        {
            var assembly = Assembly.Load(AssemblyPath);
            return assembly.CreateInstance(className);
        }
    }
}
	
	然后修改DBSession
	
	 private IUlricaDal _ulricaDal;
        public IUlricaDal UlricaDal
        {
            get
            {
                if (_ulricaDal==null)
                {
                    //_ulricaDal = new UlricaDal();//线程内唯一
                    _ulricaDal = AbstractFactory.CreateUlricaDal();//通过抽象工厂封装了类的实例的创建
                }
                return _ulricaDal;
            }
            set
            {
                _ulricaDal = value;
            }
        }
	14:定义DBSession的接口
namespace CSharpTraining.IDAL
{
    /// <summary>
    /// 业务层调用的是数据会话层的接口
    /// </summary>
    public interface IDBSession
    {
        DbContext Db { get; }
        IUlricaDal UlricaDal { get; set; }
        bool SaveChenges();
    }
}	
	然后让DBSession实现该接口。
	
	15：定义具体的业务基类
	
	//在业务基类中完成DBSession的调用，然后将业务层中公共的方法定义在基类中，但是这些方法不知道通过DBSession来获取哪个数据操作类的实例。所以将该业务基类定义成抽象类，加上一个抽象方法，加上一个IBaseDal属性，并且让基类的构造方法调用抽象方法目的是在表现层new具体的业务子类，父类的构造方法被调用，这些执行抽象方法，但是执行的的是子类中具体的实现。业务子类知道通过DBSession获取哪个数据操作类的实例。
	
	多态
	
	namespace CSharpTraining.BLL
{
    public abstract class BaseService<T> where T : class, new()
    {
        public IDBSession CurrentDBSession
        {
            get
            {
                return new DBSession();//暂时
            }
        }
        //存放当前数据操作类的实例
        public IDAL.IBaseDal<T> CurrentDal { get; set; }
        public abstract void SetCurrentDal();
        public BaseService()
        {
            SetCurrentDal();//子类一定要实现此抽象方法
        }

        /// <summary>
        /// 查询
        /// </summary>
        /// <param name="whereLambda"></param>
        /// <returns></returns>
        public IQueryable<T> LoadEntities(Expression<Func<T, bool>> whereLambda)
        {
            return CurrentDal.LoadEntities(whereLambda);
        }


    }
}
	
	16：定义业务层的接口。
	namespace CSharpTraining.IBLL
{
    public interface IBaseService<T> where T :class,new()
    {
        IDBSession CurrentDBSession { get; }
        IDAL.IBaseDal<T> CurrentDal { get; set; }
        IQueryable<T> LoadEntities(Expression<Func<T, bool>> whereLambda);
        IQueryable<T> LoadPageEntities<s>(int pageIndex, int pageSize, out int totalCount, Expression<Func<T, bool>> whereLambda, Expression<Func<T, s>> orderByLambda, bool isAsc);

        bool DeleteEntity(T entity);
        bool EditEntity(T entity);
        T AddEntity(T entity);


    }
}

18.保证DBSession线程内唯一
namespace CSharpTraining.DALFactory
{
    public class DBSessionFactory
    {
        public static IDAL.IDBSession CreateDBSession()
        {
            IDAL.IDBSession DbSession = (IDAL.IDBSession)CallContext.GetData("dbSession");
            if (DbSession==null)
            {
                DbSession = new DALFactory.DBSession();
                CallContext.SetData("dbSession",DbSession);
            }
            return DbSession;
        }
    }
}






修改BaseService
public IDBSession CurrentDBSession
        {
            get
            {
                //return new DBSession();//暂时
                return DBSessionFactory.CreateDBSession();
            }
        }
		
namespace CSharpTraining.Web.Controllers
{
    public class UlricaController : Controller
    {
        // GET: Ulrica
        IBLL.IUlricaService UlricaService = new BLL.UlricaService();
        public ActionResult Index()
        {
            var ulricaList = UlricaService.LoadEntities(u => true).ToList();
            ViewData.Model = ulricaList;
            return View();
        }
    }
}
	17：将数据库链接字符串(model的app.config中)拷贝到web.config文件中。
	